{
	"FullScreen": {
		"body": "/* eslint-disable @typescript-eslint/no-explicit-any */\n\ntype FullscreenMethods = {\n\treadonly requestFullscreen: string;\n\treadonly exitFullscreen: string;\n\treadonly fullscreenElement: string;\n\treadonly fullscreenEnabled: string;\n\treadonly fullscreenchange: string;\n\treadonly fullscreenerror: string;\n};\n\ntype FullscreenAPI = Readonly<Partial<FullscreenMethods>> | false;\n\ntype FullscreenEvent = \"change\" | \"error\";\n\ntype Fullscreen = {\n\tenter: (element?: Element, options?: FullscreenOptions) => Promise<void>;\n\texit: () => Promise<void>;\n\ttoggle: (element?: Element, options?: FullscreenOptions) => Promise<void>;\n\tonChange: (callback: EventListener) => void;\n\tonError: (callback: EventListener) => void;\n\taddEvent: (event: FullscreenEvent, callback: EventListener) => void;\n\tremoveEvent: (event: FullscreenEvent, callback: EventListener) => void;\n\treadonly active: boolean;\n\treadonly available: boolean;\n\treadonly element?: Element;\n\treadonly api: FullscreenAPI;\n};\n\nconst methodMap: string[][] = [\n\t[\n\t\t\"requestFullscreen\",\n\t\t\"exitFullscreen\",\n\t\t\"fullscreenElement\",\n\t\t\"fullscreenEnabled\",\n\t\t\"fullscreenchange\",\n\t\t\"fullscreenerror\",\n\t],\n\t// New WebKit\n\t[\n\t\t\"webkitRequestFullscreen\",\n\t\t\"webkitExitFullscreen\",\n\t\t\"webkitFullscreenElement\",\n\t\t\"webkitFullscreenEnabled\",\n\t\t\"webkitfullscreenchange\",\n\t\t\"webkitfullscreenerror\",\n\t],\n\t// Old WebKit\n\t[\n\t\t\"webkitRequestFullScreen\",\n\t\t\"webkitCancelFullScreen\",\n\t\t\"webkitCurrentFullScreenElement\",\n\t\t\"webkitCancelFullScreen\",\n\t\t\"webkitfullscreenchange\",\n\t\t\"webkitfullscreenerror\",\n\t],\n\t[\n\t\t\"mozRequestFullScreen\",\n\t\t\"mozCancelFullScreen\",\n\t\t\"mozFullScreenElement\",\n\t\t\"mozFullScreenEnabled\",\n\t\t\"mozfullscreenchange\",\n\t\t\"mozfullscreenerror\",\n\t],\n\t[\n\t\t\"msRequestFullscreen\",\n\t\t\"msExitFullscreen\",\n\t\t\"msFullscreenElement\",\n\t\t\"msFullscreenEnabled\",\n\t\t\"MSFullscreenChange\",\n\t\t\"MSFullscreenError\",\n\t],\n];\n\nconst fullscreenAPI: FullscreenAPI = (() => {\n\tif (typeof document === \"undefined\") return false;\n\n\tconst prefix = methodMap[0];\n\tconst value: Record<string, string> = {};\n\n\tfor (const methodList of methodMap) {\n\t\tconst exitFullscreen = methodList[1];\n\n\t\tif (exitFullscreen in document) {\n\t\t\tfor (const [index, method] of methodList.entries()) {\n\t\t\t\tvalue[prefix[index]] = method;\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t}\n\n\treturn false;\n})();\n\nconst eventNameMap: Record<FullscreenEvent, string | undefined> = {\n\tchange: fullscreenAPI ? fullscreenAPI.fullscreenchange : undefined,\n\terror: fullscreenAPI ? fullscreenAPI.fullscreenerror : undefined,\n};\n\nconst fullscreen: Fullscreen = fullscreenAPI\n\t? {\n\t\t\tenter(element = document.documentElement, options) {\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tif (!fullscreenAPI || !fullscreenAPI.requestFullscreen) {\n\t\t\t\t\t\treject(new Error(\"Fullscreen API is not supported\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst onFullScreenEntered = () => {\n\t\t\t\t\t\tfullscreen.removeEvent(\"change\", onFullScreenEntered);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t};\n\n\t\t\t\t\tfullscreen.addEvent(\"change\", onFullScreenEntered);\n\n\t\t\t\t\tconst returnPromise = (element as any)[\n\t\t\t\t\t\tfullscreenAPI.requestFullscreen\n\t\t\t\t\t](options);\n\n\t\t\t\t\tif (returnPromise instanceof Promise) {\n\t\t\t\t\t\treturnPromise.then(onFullScreenEntered).catch(reject);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\texit() {\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tif (!fullscreenAPI || !fullscreenAPI.exitFullscreen) {\n\t\t\t\t\t\treject(new Error(\"Fullscreen API is not supported\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!fullscreen.active) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst onFullScreenExit = () => {\n\t\t\t\t\t\tfullscreen.removeEvent(\"change\", onFullScreenExit);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t};\n\n\t\t\t\t\tfullscreen.addEvent(\"change\", onFullScreenExit);\n\n\t\t\t\t\tconst returnPromise = (document as any)[\n\t\t\t\t\t\tfullscreenAPI.exitFullscreen\n\t\t\t\t\t]();\n\n\t\t\t\t\tif (returnPromise instanceof Promise) {\n\t\t\t\t\t\treturnPromise.then(onFullScreenExit).catch(reject);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\ttoggle(element, options) {\n\t\t\t\treturn fullscreen.active\n\t\t\t\t\t? fullscreen.exit()\n\t\t\t\t\t: fullscreen.enter(element, options);\n\t\t\t},\n\t\t\tonChange(callback) {\n\t\t\t\tfullscreen.addEvent(\"change\", callback);\n\t\t\t},\n\t\t\tonError(callback) {\n\t\t\t\tfullscreen.addEvent(\"error\", callback);\n\t\t\t},\n\t\t\taddEvent(event, callback) {\n\t\t\t\tconst eventName = eventNameMap[event];\n\t\t\t\tif (eventName) {\n\t\t\t\t\tdocument.addEventListener(eventName, callback, false);\n\t\t\t\t}\n\t\t\t},\n\t\t\tremoveEvent(event, callback) {\n\t\t\t\tconst eventName = eventNameMap[event];\n\t\t\t\tif (eventName) {\n\t\t\t\t\tdocument.removeEventListener(eventName, callback, false);\n\t\t\t\t}\n\t\t\t},\n\t\t\tget active() {\n\t\t\t\treturn fullscreenAPI && fullscreenAPI.fullscreenElement\n\t\t\t\t\t? Boolean((document as any)[fullscreenAPI.fullscreenElement])\n\t\t\t\t\t: false;\n\t\t\t},\n\t\t\tget available() {\n\t\t\t\treturn fullscreenAPI && fullscreenAPI.fullscreenEnabled\n\t\t\t\t\t? Boolean((document as any)[fullscreenAPI.fullscreenEnabled])\n\t\t\t\t\t: false;\n\t\t\t},\n\t\t\tget element() {\n\t\t\t\treturn fullscreenAPI && fullscreenAPI.fullscreenElement\n\t\t\t\t\t? (document as any)[fullscreenAPI.fullscreenElement]\n\t\t\t\t\t: undefined;\n\t\t\t},\n\t\t\tapi: fullscreenAPI,\n\t\t}\n\t: ({ available: false } as Fullscreen);\n\nexport default fullscreen;\n",
		"prefix": "fullscreen",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"Hook - Boolean": {
		"body": "import { useState } from \"react\";\n\nexport function useBoolean(initialState: boolean = false) {\n\tconst [value, setValue] = useState<boolean>(initialState);\n\n\treturn {\n\t\tisOn: value,\n\t\tisOff: !value,\n\t\ton: () => setValue(true),\n\t\toff: () => setValue(false),\n\t\ttoggle: () => setValue((prev) => !prev),\n\t\tset: setValue,\n\t};\n}\n",
		"prefix": "hboolean",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"Hook - Click": {
		"body": "import { useEffect, useRef } from \"react\";\n\nexport function useClick(\n\thandler: (event: MouseEvent) => void,\n\ttargetRef?: React.RefObject<HTMLElement>,\n) {\n\tconst handlerRef = useRef(handler);\n\n\tuseEffect(() => {\n\t\thandlerRef.current = handler;\n\t}, [handler]);\n\n\tuseEffect(() => {\n\t\tif (typeof window === \"undefined\") return;\n\n\t\tconst eventListener = (event: MouseEvent) => {\n\t\t\tif (\n\t\t\t\ttargetRef?.current &&\n\t\t\t\t!targetRef.current.contains(event.target as Node)\n\t\t\t) {\n\t\t\t\thandlerRef.current(event);\n\t\t\t}\n\t\t};\n\n\t\twindow.addEventListener(\"click\", eventListener);\n\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"click\", eventListener);\n\t\t};\n\t}, [targetRef]);\n}\n",
		"prefix": "hook-click",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"Hook - Clipboard": {
		"body": "import { useEffect, useRef, useState } from \"react\";\n\nexport function useClipboard(defaultText = \"\") {\n\tconst [copied, setCopied] = useState(false);\n\tconst textRef = useRef(defaultText);\n\tconst timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n\tconst copy = (text?: string) => {\n\t\tconst contentToCopy = text?.trim() || textRef.current?.trim();\n\n\t\tif (!contentToCopy || !navigator.clipboard) return;\n\n\t\tnavigator.clipboard\n\t\t\t.writeText(contentToCopy)\n\t\t\t.then(() => {\n\t\t\t\tsetCopied(true);\n\n\t\t\t\tif (timeoutRef.current) clearTimeout(timeoutRef.current);\n\n\t\t\t\ttimeoutRef.current = setTimeout(() => setCopied(false), 2000);\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tconsole.error(\"Clipboard copy failed\", error);\n\t\t\t});\n\t};\n\n\tconst setText = (newText: string) => {\n\t\ttextRef.current = newText;\n\t};\n\n\tuseEffect(() => {\n\t\treturn () => {\n\t\t\tif (timeoutRef.current) clearTimeout(timeoutRef.current);\n\t\t};\n\t}, []);\n\n\treturn { copy, copied, setText };\n}\n",
		"prefix": "hclipboard",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"Hook - Counter": {
		"body": "import { useCallback, useRef, useState } from \"react\";\n\nexport function useCounter(initialValue: number = 0, step: number = 1) {\n\tconst [count, setCount] = useState(initialValue);\n\tconst initialRef = useRef(initialValue);\n\n\tconst increment = useCallback(() => setCount((x) => x + step), [step]);\n\tconst decrement = useCallback(() => setCount((x) => x - step), [step]);\n\tconst reset = useCallback(() => setCount(initialRef.current), []);\n\tconst set = useCallback((value: number) => setCount(value), []);\n\n\treturn { count, increment, decrement, reset, set };\n}\n",
		"prefix": "hook-counter",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"Hook - Float": {
		"body": "import type {\n\tFloatingRootContext,\n\tMiddleware,\n\tPlacement,\n\tReferenceType,\n\tUseFloatingReturn,\n} from \"@floating-ui/react\";\nimport {\n\tflip,\n\toffset,\n\tshift,\n\tuseClick,\n\tuseFloating,\n\tuseInteractions as useFloatingInteractions,\n\tuseFocus,\n\tuseHover,\n} from \"@floating-ui/react\";\n\ntype Interaction = \"hover\" | \"click\" | \"focus\";\n\nexport interface UseFloatOptions {\n\topen: boolean;\n\tonOpenChange: (open: boolean) => void;\n\tplacement?: Placement;\n\tmiddleware?: Middleware[];\n\tinteractions?: Interaction[];\n}\n\ninterface ReferenceProps {\n\tref: (node: ReferenceType | null) => void;\n}\n\ninterface FloatingProps {\n\tref: (node: HTMLElement | null) => void;\n\tstyle: React.CSSProperties;\n}\n\nexport interface UseFloatReturn extends Omit<UseFloatingReturn, \"refs\" | \"floatingStyles\"> {\n\treferenceProps: ReferenceProps;\n\tfloatingProps: FloatingProps;\n}\n\nfunction useInteractions(\n\tcontext: FloatingRootContext,\n\tinteractions: Interaction[],\n) {\n\tconst interactionMap = {\n\t\thover: useHover(context),\n\t\tfocus: useFocus(context),\n\t\tclick: useClick(context),\n\t};\n\n\treturn useFloatingInteractions(\n\t\tinteractions.map((key) => interactionMap[key]),\n\t);\n}\n\nexport function useFloat({\n\tinteractions = [\"hover\"],\n\tmiddleware = [offset(7)],\n\tplacement = \"top\",\n\t...options\n}: UseFloatOptions): UseFloatReturn {\n\tconst { refs, floatingStyles, ...floatingReturn } = useFloating({\n\t\t...options,\n\t\tmiddleware: [flip(), shift(), ...middleware],\n\t\tplacement,\n\t});\n\n\tconst { getFloatingProps, getReferenceProps } = useInteractions(\n\t\tfloatingReturn.context,\n\t\tinteractions,\n\t);\n\n\treturn {\n\t\t...floatingReturn,\n\t\treferenceProps: {\n\t\t\tref: refs.setReference,\n\t\t\t...getReferenceProps(),\n\t\t},\n\t\tfloatingProps: {\n\t\t\tref: refs.setFloating,\n\t\t\tstyle: floatingStyles,\n\t\t\t...getFloatingProps(),\n\t\t},\n\t};\n}\n",
		"prefix": "hook-float",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"Hook - Hover": {
		"body": "import { useEffect, useRef, useState } from \"react\";\n\nexport function useHover<T extends HTMLElement>(initialRef?: React.RefObject<T>) {\n\tconst [hovered, setHovered] = useState(false);\n\tconst internalRef = useRef<T>(null);\n\tconst ref = initialRef || internalRef;\n\n\tuseEffect(() => {\n\t\tconst element = ref.current;\n\t\tif (!element) return;\n\n\t\tconst handleMouseEnter = () => setHovered(true);\n\t\tconst handleMouseLeave = () => setHovered(false);\n\n\t\telement.addEventListener(\"mouseenter\", handleMouseEnter);\n\t\telement.addEventListener(\"mouseleave\", handleMouseLeave);\n\n\t\treturn () => {\n\t\t\telement.removeEventListener(\"mouseenter\", handleMouseEnter);\n\t\t\telement.removeEventListener(\"mouseleave\", handleMouseLeave);\n\t\t};\n\t}, [ref.current]);\n\n\treturn { hovered, ref };\n}\n",
		"prefix": "hook-hover",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"Hook - Local Storage": {
		"body": "import { useCallback, useEffect, useState } from \"react\";\n\nconst IS_SERVER = typeof window === \"undefined\";\n\nexport function serialize<T>(value: T) {\n\ttry {\n\t\treturn typeof value === \"object\" && value !== null\n\t\t\t? JSON.stringify(value)\n\t\t\t: String(value);\n\t} catch (error) {\n\t\tconsole.error(\"Serialization error:\", error);\n\t\treturn \"\";\n\t}\n}\n\nexport function deserialize<T>(value: string | null, defaultValue: T): T {\n\ttry {\n\t\tif (value === null) return defaultValue;\n\n\t\tif (typeof defaultValue === \"object\" && defaultValue !== null)\n\t\t\treturn JSON.parse(value);\n\n\t\tif (typeof defaultValue === \"boolean\") return (value === \"true\") as T;\n\n\t\tif (typeof defaultValue === \"number\") return Number(value) as unknown as T;\n\n\t\treturn value as T;\n\t} catch (error) {\n\t\tconsole.error(\"Deserialization error:\", error);\n\t\treturn defaultValue;\n\t}\n}\n\nexport function useLocalStorage<T>(key: string, initialValue: T) {\n\tconst [value, setValue] = useState<T | null>(() => {\n\t\tif (IS_SERVER) return initialValue;\n\n\t\ttry {\n\t\t\tconst item = window.localStorage.getItem(key);\n\n\t\t\treturn item !== null ? deserialize(item, initialValue) : null;\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Error accessing localStorage:\", error);\n\n\t\t\treturn initialValue;\n\t\t}\n\t});\n\n\tconst set = useCallback(\n\t\t(newValue: T | ((prev: T | null) => T)) => {\n\t\t\tif (IS_SERVER) return;\n\n\t\t\ttry {\n\t\t\t\tsetValue((prev) => {\n\t\t\t\t\tconst updatedValue =\n\t\t\t\t\t\tnewValue instanceof Function ? newValue(prev) : newValue;\n\t\t\t\t\twindow.localStorage.setItem(key, serialize(updatedValue));\n\t\t\t\t\treturn updatedValue;\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"Error setting localStorage:\", error);\n\t\t\t}\n\t\t},\n\t\t[key],\n\t);\n\n\tconst remove = useCallback(() => {\n\t\tif (IS_SERVER) return;\n\n\t\ttry {\n\t\t\twindow.localStorage.removeItem(key);\n\t\t\tsetValue(null);\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Error removing localStorage:\", error);\n\t\t}\n\t}, [key]);\n\n\tuseEffect(() => {\n\t\tif (IS_SERVER) return;\n\n\t\tconst item = window.localStorage.getItem(key);\n\n\t\tif (item === null && value !== null) {\n\t\t\twindow.localStorage.setItem(key, serialize(value));\n\t\t}\n\n\t\tconst handleStorage = (event: StorageEvent) => {\n\t\t\tif (event.key === key) {\n\t\t\t\tsetValue(\n\t\t\t\t\tevent.newValue ? deserialize(event.newValue, initialValue) : null,\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\n\t\twindow.addEventListener(\"storage\", handleStorage);\n\t\treturn () => window.removeEventListener(\"storage\", handleStorage);\n\t}, [key, value, initialValue]);\n\n\treturn { value, set, remove };\n}\n",
		"prefix": "hook-local-storage",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"Hook - Ripple": {
		"body": "import { useCallback } from \"react\";\n\ninterface UseRippleProps {\n\tdisable?: boolean;\n\tcolor?: string;\n}\n\nexport function useRipple(options: UseRippleProps = {}) {\n\tconst { disable, color = \"rgba(255, 255, 255, 0.25)\" } = options;\n\n\tconst createRipple = useCallback(\n\t\t(event: React.MouseEvent<HTMLElement>) => {\n\t\t\tif (disable) return;\n\n\t\t\tconst target = event.currentTarget;\n\t\t\tconst { left, top } = target.getBoundingClientRect();\n\n\t\t\tconst width = target.offsetWidth;\n\t\t\tconst height = target.offsetHeight;\n\t\t\tconst size = Math.max(width, height);\n\n\t\t\tconst x = event.clientX - left - size / 2;\n\t\t\tconst y = event.clientY - top - size / 2;\n\n\t\t\tconst duration = Math.min(1.5, Math.max(1.05, size / 300));\n\n\t\t\tconst rippleElement = document.createElement(\"span\");\n\n\t\t\tObject.assign(rippleElement.style, {\n\t\t\t\twidth: size + \"px\",\n\t\t\t\theight: size + \"px\",\n\t\t\t\ttop: y + \"px\",\n\t\t\t\tleft: x + \"px\",\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttransform: \"scale(0)\",\n\t\t\t\topacity: \"1\",\n\t\t\t\tborderRadius: \"50%\",\n\t\t\t\tpointerEvents: \"none\",\n\t\t\t\tbackgroundColor: color,\n\t\t\t\tanimation: \"ripple \" + duration + \"s ease-out\",\n\t\t\t});\n\n\t\t\trippleElement.addEventListener(\"animationend\", () => {\n\t\t\t\trippleElement.remove();\n\t\t\t});\n\n\t\t\ttarget.appendChild(rippleElement);\n\t\t},\n\t\t[disable, color],\n\t);\n\n\treturn createRipple;\n}\n",
		"prefix": "hook-ripple",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"Hook - Toggle": {
		"body": "import { useCallback, useState } from \"react\";\n\nexport function useToggle(initialState: boolean = false) {\n\tconst [state, setState] = useState<boolean>(initialState);\n\n\tconst toggle = useCallback(() => {\n\t\tsetState((prev) => !prev);\n\t}, []);\n\n\treturn [state, toggle] as const;\n}\n",
		"prefix": "hook-toggle",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"React Hook": {
		"body": "function use${1:${TM_FILENAME_BASE/^(use[\\s._-]*)?([a-zA-Z0-9])|[\\s._-]+([a-zA-Z0-9])/${2:/upcase}${3:/upcase}/g}}() {\n\t$0\n}\n",
		"prefix": "rh",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"React Hook - Export": {
		"body": "export function use${1:${TM_FILENAME_BASE/^(use[\\s._-]*)?([a-zA-Z0-9])|[\\s._-]+([a-zA-Z0-9])/${2:/upcase}${3:/upcase}/g}}() {\n\t$0\n}\n",
		"prefix": "rhe",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"Use - Callback": {
		"body": "const $2 = useCallback$1(() => {\n\t$3\n}, [$4]);",
		"prefix": "uca",
		"scope": "javascript,javascriptreact,typescript,typescriptreact"
	},
	"Use - Context": {
		"body": "const {$3} = useContext$1($2)$0",
		"prefix": "uco",
		"scope": "javascript,javascriptreact,typescript,typescriptreact"
	},
	"Use - Memo": {
		"body": "const ${1:first} = useMemo$0(${2:second}, ${3:third});",
		"prefix": "ume",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"Use - Reducer": {
		"body": "const [${1:state}, ${2:dispatch}] = useReducer$0(${3:params});",
		"prefix": "ured",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"Use - Ripple": {
		"body": "const ${1:name} = useRipple$0($2);",
		"prefix": "ripple",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	},
	"Use - Transition": {
		"body": "const [${1:isPending}, ${2:startTransition}] = useTransition$0();",
		"prefix": "utr",
		"scope": "javascript,typescript,javascriptreact,typescriptreact"
	}
}
